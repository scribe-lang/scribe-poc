/*
	MIT License

	Copyright (c) 2021 Scribe Language Repositories

	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so.
*/

#include "parser/Stmts.hpp"
#include "parser/Type.hpp"

namespace sc
{
namespace parser
{
///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBlock ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtBlock::mergeValues(Stmt *stmt)
{
	this->value  = stmt->value;
	StmtBlock *s = as<StmtBlock>(stmt);
	for(size_t i = 0; i < stmts.size(); ++i) {
		if(!s) break;
		stmts[i]->mergeValues(s->stmts[i]);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtType /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtType::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtType *s = as<StmtType>(stmt);
	if(fn) fn->mergeValues(s->fn);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtSimple ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtSimple::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// StmtFnCallInfo //////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtFnCallInfo::mergeValues(Stmt *stmt)
{
	this->value	  = stmt->value;
	StmtFnCallInfo *s = as<StmtFnCallInfo>(stmt);
	for(size_t i = 0; i < templates.size(); ++i) {
		templates[i]->mergeValues(s->templates[i]);
	}
	for(size_t i = 0; i < args.size(); ++i) {
		args[i]->mergeValues(s->args[i]);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtExpr /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtExpr::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtExpr *s = as<StmtExpr>(stmt);
	if(lhs) lhs->mergeValues(s->lhs);
	if(rhs) rhs->mergeValues(s->rhs);
	// TODO: or-var & or-blk
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtVar //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtVar::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtVar *s  = as<StmtVar>(stmt);
	if(val) val->mergeValues(s->val);
	if(vtype) vtype->mergeValues(s->vtype);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnSig ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtFnSig::mergeValues(Stmt *stmt)
{
	this->value  = stmt->value;
	StmtFnSig *s = as<StmtFnSig>(stmt);
	for(size_t i = 0; i < args.size(); ++i) {
		args[i]->mergeValues(s->args[i]);
	}
	if(rettype) rettype->mergeValues(s->rettype);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnDef ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtFnDef::mergeValues(Stmt *stmt)
{
	this->value  = stmt->value;
	StmtFnDef *s = as<StmtFnDef>(stmt);
	sig->mergeValues(s->sig);
	if(blk) blk->mergeValues(s->blk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtHeader ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtHeader::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtLib //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtLib::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtExtern ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtExtern::mergeValues(Stmt *stmt)
{
	this->value   = stmt->value;
	StmtExtern *s = as<StmtExtern>(stmt);
	sig->mergeValues(s->sig);
	if(headers) headers->mergeValues(s->headers);
	if(libs) libs->mergeValues(s->libs);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtEnum //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtEnum::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtStruct /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtStruct::mergeValues(Stmt *stmt)
{
	this->value   = stmt->value;
	StmtStruct *s = as<StmtStruct>(stmt);
	for(size_t i = 0; i < fields.size(); ++i) {
		fields[i]->mergeValues(s->fields[i]);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtVarDecl ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtVarDecl::mergeValues(Stmt *stmt)
{
	this->value    = stmt->value;
	StmtVarDecl *s = as<StmtVarDecl>(stmt);
	for(size_t i = 0; i < decls.size(); ++i) {
		decls[i]->mergeValues(s->decls[i]);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtCond /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtCond::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtCond *s = as<StmtCond>(stmt);
	for(size_t i = 0; i < conds.size(); ++i) {
		if(conds[i].cond) conds[i].cond->mergeValues(conds[i].cond);
		conds[i].blk->mergeValues(conds[i].blk);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtForIn /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtForIn::mergeValues(Stmt *stmt)
{
	this->value  = stmt->value;
	StmtForIn *s = as<StmtForIn>(stmt);
	in->mergeValues(s->in);
	blk->mergeValues(s->blk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFor //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtFor::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtFor *s  = as<StmtFor>(stmt);
	if(init) init->mergeValues(s->init);
	if(cond) cond->mergeValues(s->cond);
	if(incr) incr->mergeValues(s->incr);
	blk->mergeValues(s->blk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtWhile ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtWhile::mergeValues(Stmt *stmt)
{
	this->value  = stmt->value;
	StmtWhile *s = as<StmtWhile>(stmt);
	if(cond) cond->mergeValues(s->cond);
	blk->mergeValues(s->blk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtRet //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtRet::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
	StmtRet *s  = as<StmtRet>(stmt);
	if(val) val->mergeValues(s->val);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtContinue ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtContinue::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBreak ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

void StmtBreak::mergeValues(Stmt *stmt)
{
	this->value = stmt->value;
}
} // namespace parser
} // namespace sc